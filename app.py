# -*- coding: utf-8 -*-
"""app.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JlCgfpyODjfTTE1-zVD5rnk3XPk_nq9b
"""

pip install streamlit

{"id":"58291","variant":"code","title":"Streamlit U-Net Deployment App"}
import streamlit as st
import numpy as np
import cv2
import tensorflow as tf
from tensorflow.keras import layers, Model
import matplotlib.pyplot as plt

# -------------------------
# (1) Preprocessing functions
# -------------------------

image_size = (128, 128)

def preprocess_image(img):
    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    img = cv2.resize(img, image_size)
    img = img / 255.0
    return img

def preprocess_mask(mask):
    mask_bin = (mask > 0.5).astype(np.uint8)
    return mask_bin

# -------------------------
# (2) Simple U-Net Model (same as your training)
# -------------------------

def simple_unet(input_shape=(128,128,3)):
    inputs = layers.Input(input_shape)

    c1 = layers.Conv2D(16,3,activation='relu',padding='same')(inputs)
    c1 = layers.Conv2D(16,3,activation='relu',padding='same')(c1)
    p1 = layers.MaxPooling2D()(c1)

    c2 = layers.Conv2D(32,3,activation='relu',padding='same')(p1)
    c2 = layers.Conv2D(32,3,activation='relu',padding='same')(c2)
    p2 = layers.MaxPooling2D()(c2)

    c3 = layers.Conv2D(64,3,activation='relu',padding='same')(p2)
    c3 = layers.Conv2D(64,3,activation='relu',padding='same')(c3)

    u2 = layers.UpSampling2D()(c3)
    u2 = layers.Concatenate()([u2, c2])
    c4 = layers.Conv2D(32,3,activation='relu',padding='same')(u2)
    c4 = layers.Conv2D(32,3,activation='relu',padding='same')(c4)

    u1 = layers.UpSampling2D()(c4)
    u1 = layers.Concatenate()([u1, c1])
    c5 = layers.Conv2D(16,3,activation='relu',padding='same')(u1)
    c5 = layers.Conv2D(16,3,activation='relu',padding='same')(c5)

    outputs = layers.Conv2D(1,1,activation='sigmoid')(c5)

    return Model(inputs, outputs)

# -------------------------
# (3) Load the trained model
# -------------------------

st.title("ğŸŒ Land Classification â€“ Desert vs Agriculture (U-Net)")
st.write("Upload an image and the model will detect agricultural areas.")

model_path = "model_unet.h5"

try:
    model = tf.keras.models.load_model(model_path)
    st.success("Model loaded successfully!")
except:
    st.error("âŒ Could not load model_unet.h5 â€” please upload it to the same folder.")
    st.stop()

uploaded_file = st.file_uploader("Upload an aerial image:", type=["jpg","jpeg","png"])

# ------------------------------------------------------
# (4) Prediction + Drawing the overlay
# ------------------------------------------------------

def overlay_mask(img, mask):
    mask_bin = (mask[:,:,0] > 0.5)

    overlay = img.copy()
    overlay[mask_bin] = (overlay[mask_bin] * 0.4 + np.array([0,255,0]) * 0.6).astype(np.uint8)

    return overlay, mask_bin

# ------------------------------------------------------
# (5) If user uploads an image â†’ Show prediction
# ------------------------------------------------------

if uploaded_file is not None:
    # Read image
    file_bytes = np.asarray(bytearray(uploaded_file.read()), dtype=np.uint8)
    img = cv2.imdecode(file_bytes, cv2.IMREAD_COLOR)

    st.image(img, caption="Original Image", use_column_width=True)

    img_pre = preprocess_image(img)

    pred_mask = model.predict(np.expand_dims(img_pre, 0))[0]
    overlay, mask_bin = overlay_mask((img_pre*255).astype(np.uint8), pred_mask)

    prop_agri = np.sum(mask_bin) / (mask_bin.shape[0] * mask_bin.shape[1])

    st.subheader("Prediction Results:")
    if prop_agri > 0.05:
        st.success(f"ğŸŒ± Suitable for agriculture â€” {prop_agri*100:.2f}% green area detected")
    else:
        st.warning(f"ğŸœï¸ Mostly desert â€” {prop_agri*100:.2f}% green area detected")

    st.image(pred_mask[:,:,0], caption="Predicted Mask", clamp=True, width=350)
    st.image(overlay, caption="Overlay Output", use_column_width=True)
